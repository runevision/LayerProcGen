<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LayerProcGen: Effect Distance and Padding</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="LayerProcGenLogoSmall.png"/></td>
  <td id="projectalign">
   <div id="projectname">LayerProcGen<span id="projectnumber">&#160;v0.1.0</span>
   </div>
   <div id="projectbrief">Layer-based infinite procedural generation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_EffectDistance.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Effect Distance and Padding</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md6"></a></p>
<p>When a chunk in one layer requests data from another layer, the data is usually spatial, and the chunk needs at mimimum the data inside its own world space bounds.</p>
<p>If the chunk needs to do any kind of contextual processing, it'll need data covering a larger area than just its own bounds - the bounds need appropriate <em>padding</em>.</p>
<p>The padding needs to be specified in two ways in the code:</p>
<ul>
<li>When the chunk requests data from another layer within specified bounds.</li>
<li>When specifying the layer dependency in the layer constructor.</li>
</ul>
<p>In the layer dependency, the padding is always specified in world space units, for example:</p>
<div class="fragment"><div class="line"><span class="comment">// Code in layer&#39;s constructor. Specify a layer dependecy with</span></div>
<div class="line"><span class="comment">// horizontal and vertical padding of 16 world space units.</span></div>
<div class="line">AddLayerDependency(</div>
<div class="line">    <span class="keyword">new</span> LayerDependency(OtherLayer.instance, <span class="keyword">new</span> Point(16, 16)));</div>
</div><!-- fragment --><p>In the data request, the requested bounds (which should include padding) can be specified in world space units or in some other type of units if that's more convenient. This depends on how you design the request API.</p>
<div class="fragment"><div class="line"><span class="comment">// Code in chunk&#39;s Create method. Get points in chunk&#39;s own bounds</span></div>
<div class="line"><span class="comment">// plus horizontal and vertical padding of 16 world space units.</span></div>
<div class="line">PointsLayer.instance.GetPointsInBounds(</div>
<div class="line">    <span class="keyword">this</span>, outPoints, bounds.GetExpanded(<span class="keyword">new</span> Point(16, 16)));</div>
</div><!-- fragment --><p>How much padding is needed depends on what processing the chunk needs to do. This is where the concept of the <em>effect distance</em> comes into play.</p>
<h1>Effect distance</h1>
<p>When doing contextual generation, we don't want discontinuities at the chunk edges. We want the end result to be continuous and seamless as if we had processed the entire (infinite) plane of data at once, even though it’s actually done chunk by chunk.</p>
<p>To ensure such integrity of the end result, we need to think about the <em>effect distance</em> of a contextual process. The effect distance is a measure of how far away input data can affect the output data at a given position.</p>
<div class="image">
<img src="EffectDistanceChunkAndRadius.png" alt=""/>
</div>
    <p>This is how the appropriate amount of <em>padding</em> for a chunk's data request is decided: It must be large enough to fully encompass the effect distance of every point within the chunk. This means the padding must be at least as large as the effect distance.</p>
<h1>"Modifying" data</h1>
<p>Some kinds of generation or processing that a chunk can do have the same type of input and output.</p>
<ul>
<li>Initial pixels → blurred pixels</li>
<li>Initial point distances → relaxed point distances</li>
<li>Initial terrain heights → eroded terrain heights</li>
</ul>
<p>We can think of this as “modifying” data, even though the output is stored in a separate layer, and the input data remains untouched in the layer it came from.</p>
<p>Let's look at a few examples of how to determine the effect distance when "modifying" data.</p>
<h1>Example: Blurring data</h1>
<p>Consider a RasterLayer which provides pixels based on a global deterministic pattern, and a FilterLayer that's responsible for calculating and storing a blurred version of the pattern.</p>
<p>If the output should be blurred by a 5 x 5 kernel, that's a blur radius of <span style="color:orange">2 pixels</span> and hence an <em>effect distance</em> of 2 pixels too.</p>
<div class="image">
<img src="PaddingBlur.png" alt=""/>
</div>
    <p>We can design the data request API to take bounds in pixels rather than in world space units. In this case, we can calculate the pixel bounds corresponding to the output chunk, and then expand those by <span style="color:orange">2</span> in all directions to get the input pixel bounds.</p>
<p>However, when we specify the layer dependency in the layer constructor, the padding needs to be specified in world space units. If each FilterLayer chunk is <span style="color:purple">30 x 30 world space units</span> large and covers <span style="color:green">10 x 10 pixels</span>, then the effect distance of <span style="color:orange">2 pixels</span> corresponds to <span style="color:orange">2</span> * ( <span style="color:purple">30</span> / <span style="color:green">10</span> ) = <span style="color:blue">6</span> world space units.</p>
<h1>Multiple iterations</h1>
<p>If an algorithm operates over multiple iterations, then the effect distance scales with the number of iterations. If we consider the FilterLayer example from before, but apply the blur filter twice, then the effect distance for each iteration needs to be added together, and the padding ends needing to be twice as large.</p>
<div class="image">
<img src="PaddingBlurIterations.png" alt=""/>
</div>
    <h1>No edge cases</h1>
<p>Filter algorithms often have code for handling literal edge cases such as pixels at the edge of an image. Generally data is “missing”, and the algorithm decides what values to use as a fallback.</p>
<p>However, for the “infinite” blurring we want, no edge case handling is needed. This is because we ensure that the input is larger than the output, such that no data is “missing”.</p>
<p>As a rule of thumb, if you are handling edges specially, you’re likely doing something wrong, and will see edge discontinuities or other artefacts that compromise the output integrity.</p>
<h1>Example: Point distance relaxation</h1>
<p>Point placed randomly can have a very uneven distribution, where some points are much closer together than others. A relaxation algorithm can be used to even out distances between such points.</p>
<p>Point distance relaxation can have a well-defined effect distance if there’s a maximum distance past which two points no longer affect each other. In that case, that maximum distance is the effect distance.</p>
<p>As mentioned further up, if the algorithm runs over multiple iterations (as is common for relaxation algorithms), the effect distances per iteration need to be added together. This can quickly add up to a lot of required generated input data, so it's a good idea to see how few iterations, and how small an effect distance per iteration, you can get away with and still get acceptable results.</p>
<p>If multiple iterations are run without using sufficient padding in the requested data, the output will still be deterministic, but won't retain integrity, due to being compromised by missing data. This is not as obvious as in the blurring example, since there isn't necessaily edge case handling code involved in relaxation algorithms that could function as a red flag.</p>
<p>A way to think about this is that in each relaxation step, the data (for example points) within the single-iteration effect distance of the data edge gets compromised by missing data. In the next iteration, all data within the effect distance of the already compromised data gets compromised too, and so on. The compromised state of data propogates with the speed of one effect distance per iteration. If we stop before it reaches the bounds of the chunk, the output of the chunk retains integrity - otherwise the chunk output is compromised.</p>
<h1>Effect distance more generally</h1>
<p>We’ve considered effect distances when “modifying” data, but we can apply it to other processes to, as long as we can reason about how far away input data can influence output data.</p>
<p>Consider pathfinding between a start and goal point based on height data, used to generate natural paths through the terrain. How far away height data can affect the result path? This seems non-trivial to calculate.</p>
<p>However, rather than calculating an effect distance, sometimes an effect distance can simply be chosen and enforced. In the case of pathfinding, the pathfinding algorithm can be restricted to only consider points within a certain distance of the start-to-goal line segment.</p>
<p>This way the effect distance is controlled directly, and the needed amount of padding is known based on that.</p>
<div class="image">
<img src="PaddingPathfinding.png" alt=""/>
</div>
    <h1>Internal layer levels</h1>
<p>When <a class="el" href="md_InternalLayerLevels.html">internal layer levels</a> are used and a chunk uses data from a lower level, we don't specify data requests within given padded bounds but rather just have all data from the neighboring chunks available.</p>
<p>In this case it's up to the implementation of the chunk to ensure that the effect distance is at most the size of one chunk. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
