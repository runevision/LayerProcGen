<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LayerProcGen: Internal Layer Levels</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="LayerProcGenLogoSmall.png"/></td>
  <td id="projectalign">
   <div id="projectname">LayerProcGen<span id="projectnumber">&#160;v0.1.0</span>
   </div>
   <div id="projectbrief">Layer-based infinite procedural generation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_InternalLayerLevels.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Internal Layer Levels</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md7"></a> Normally layers are separate, and chunk sizes are an implementation detail of each layer.</p>
<p>LayerProcGen also supports an alternative pattern: Internal levels within a layer.</p>
<p>Each layer level is like its own layer, except:</p>
<ul>
<li>The chunks are shared across the levels and are thus also all of the same size. A <code>level</code> property of each chunk keeps track of which level it has currently been generated up to.</li>
<li>The layer and chunk class is shared for all the levels, and there is no explicit data request interface between levels.</li>
<li>Each level is assumed to depend on the immediate neighbor chunks in the previous level.</li>
</ul>
<div class="image">
<img src="InternalLayerLevels.png" alt=""/>
<div class="caption">
A layer with three internal layer levels.</div></div>
    <h1>Basic setup</h1>
<p>To make use of internal layer levels, override the <code>GetLevelCount</code> method of your layer and make it return a constant which is the amount of levels of the layer.</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keywordtype">int</span> GetLevelCount() { <span class="keywordflow">return</span> 3; }</div>
</div><!-- fragment --><p>Optionally you can use an enum to associate names with each layer, which may make it easier to remember what each layer does. Using an additional <code>Length</code> enum entry at the end makes it simple to get the amount of levels based on the enum.</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Levels { Generation, Processing, Instantiation, Length }</div>
<div class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keywordtype">int</span> GetLevelCount() { <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)Levels.Length; }</div>
</div><!-- fragment --><p>The Create method of the chunk takes a level parameter which specifies which level is being created or destroyed. You can structure your code like this:</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>ExampleChunk : LayerChunk&lt;ExampleLayer, ExampleChunk&gt; {</div>
<div class="line">    <span class="comment">// Data for Generation level of this chunk goes here.</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Data for Processing level of this chunk goes here.</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Data for Instantiation level of this chunk goes here.</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keywordtype">void</span> Create(<span class="keywordtype">int</span> level, <span class="keywordtype">bool</span> destroy) {</div>
<div class="line">        <span class="keywordflow">if</span> (level == (<span class="keywordtype">int</span>)ExampleLayer.Levels.Generation) {</div>
<div class="line">            <span class="keywordflow">if</span> (destroy) {</div>
<div class="line">                <span class="comment">// Destroy data for level 0 of this chunk here.</span></div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> {</div>
<div class="line">                <span class="comment">// Create data for level 0 of this chunk here.</span></div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (level == (<span class="keywordtype">int</span>)ExampleLayer.Levels.Processing) {</div>
<div class="line">            <span class="keywordflow">if</span> (destroy) {</div>
<div class="line">                <span class="comment">// Destroy data for level 1 of this chunk here.</span></div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> {</div>
<div class="line">                <span class="comment">// Create data for level 1 of this chunk here.</span></div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (level == (<span class="keywordtype">int</span>)ExampleLayer.Levels.Instantiation) {</div>
<div class="line">            <span class="keywordflow">if</span> (destroy) {</div>
<div class="line">                <span class="comment">// Destroy data for level 2 of this chunk here.</span></div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> {</div>
<div class="line">                <span class="comment">// Create data for level 2 of this chunk here.</span></div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>See the <a class="el" href="md_ScriptTemplates.html">Script Templates</a> page for a full template of a chunk and layer class with internal layer levels.</p>
<h1>Data access</h1>
<p>When using internal layer levels, it's up to you to only access the right data.</p>
<ul>
<li>When a chunk generates data for a given level, it may read and write its own data for that level.</li>
<li>Additionally it may read, <em>but not modify</em>, data for lower levels stored in itself as well as the immediate neighbor chunks.</li>
</ul>
<p>The layer can implement a method such as this to let chunks access their neighbors:</p>
<div class="fragment"><div class="line"><span class="comment">// Method for chunks to get neighbor chunks. Includes chunk itself.</span></div>
<div class="line"><span class="keyword">public</span> IEnumerable&lt;ExampleChunk&gt; GetNeighborChunks(ExampleChunk chunk) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = -1; i &lt;= 1; i++) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = -1; j &lt;= 1; j++) {</div>
<div class="line">            yield <span class="keywordflow">return</span> chunks[chunk.index.x + i, chunk.index.y + j];</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h1>External dependencies</h1>
<p>Assuming two layers ALayer and BLayer, if ALayer is using internal layer levels, BLayer can specify a dependency on a specific level of ALayer by supplying a parameter after the padding which indicates the required "provider" level.</p>
<div class="fragment"><div class="line"><span class="comment">// Code in BLayer constructor.</span></div>
<div class="line"><span class="keywordtype">int</span> otherProviderLevel = (int)ALayer.Levels.Processing);</div>
<div class="line">AddLayerDependency(<span class="keyword">new</span> LayerDependency(ALayer.instance, <span class="keyword">new</span> Point(16, 16), otherProviderLevel);</div>
</div><!-- fragment --><p>The default is the highest level, when no level parameter is specified.</p>
<p>Likewise, ALayer can specify that a specific level of its own has a dependency on BLayer by supplying a parameter prior to the LayerDependency which specify its own "user" level of the dependency.</p>
<div class="fragment"><div class="line"><span class="comment">// Code in ALayer constructor.</span></div>
<div class="line"><span class="keywordtype">int</span> ownUserLevel = (int)Levels.Instantiation;</div>
<div class="line">AddLayerDependency(ownUserLevel, <span class="keyword">new</span> LayerDependency(BLayer.instance, <span class="keyword">new</span> Point(16, 16)));</div>
</div><!-- fragment --><p>The default is the lowest level if no level parameter is specified.</p>
<h1>Pros and cons</h1>
<p>Using internal layer levels can be beneficial in certain cases, but can also have disadcantages.</p>
<p><b>Pros</b></p>
<ul>
<li>If you have generation logic which does not treat chunk size as an implementation detail, but depends on multiple layers having the same chunk size, internal layer levels may reflect this better than using separate layers.</li>
<li>For certain use cases it may be easier to simply know that you have adjacent chunks available from the lower level than to reason about and calculate how much padding is needed for a data request.</li>
<li>There can be slightly less overhead in how data is accessed.</li>
</ul>
<p><b>Cons</b></p>
<ul>
<li>Different levels of a layer are tightly coupled which may be less flexible.</li>
<li>Since all layer levels share the same chunks, and thus have access to the same stored chunk data, the framework offers less guidance towards only accessing the allowed data for each layer level. This requires dilligence of the implementer to keep track of which data is associated with which layer levels. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
